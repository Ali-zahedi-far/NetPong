# NetPong — پروژه‌ی  (TCP) با Python + pygame

این پروژه یک بازی دو‌نفره‌ی ساده شبیه «پینگ‌پنگ چهارضلعی» است که:
- معماری **Client-Server** دارد (سرور مرجع فیزیک و امتیازدهی است).
- از **TCP sockets** برای تبادل داده‌ها (JSON line-based) استفاده می‌کند.
- گرافیک با **pygame** رسم می‌شود.
- تنظیمات پیش از شروع بازی با **Tkinter** انجام می‌شود (نقش بازیکن، IP/Port، تعداد توپ، امتیاز هدف، زمان بازی).

> نکته: تمام منطق برخورد، امتیازدهی، همگام‌سازی، حلقه بازی و پردازش هم‌زمان (threading) طبق خواسته پروژه پیاده‌سازی شده است.  
> برای **امتیاز اضافه** (🌟) نیز مستندسازی کامل همین فایل و فرم تنظیمات گرافیکی ارائه شده است.

---

## نحوه اجرا

1) پیش‌نیازها را نصب کنید:
```bash
pip install -r requirements.txt
```

2) بازی را اجرا کنید:
```bash
python run.py
```
پس از اجرا، فرم تنظیمات باز می‌شود. یکی از سیستم‌ها نقش **Host (Server + Player A)** را می‌گیرد و سیستم دیگر **Client (Player B)**.  
- **Host** فقط پورت را تعیین می‌کند (پیش‌فرض: `50007`) و تعداد توپ/امتیاز/زمان را انتخاب می‌کند.  
- **Client** باید **IP** سیستم Host و همان **Port** را وارد کند.

> اگر هر دو نفر روی یک سیستم برای تست اجرا کنید، در حالت Client آدرس IP را `127.0.0.1` بگذارید.

---

## کنترل‌ها (کلیدها)

- **بازیکن A (Host)** — دو پدل روی اضلاع **بالا** (حرکت افقی) و **راست** (حرکت عمودی):
  - پدل بالا: `A` و `D`
  - پدل راست: `W` و `S`

- **بازیکن B (Client)** — دو پدل روی اضلاع **پایین** (حرکت افقی) و **چپ** (حرکت عمودی):
  - پدل پایین: `Left` و `Right`
  - پدل چپ: `Up` و `Down`

کلیدهای عمومی:
- `P` = توقف/ادامه بازی (Pause/Resume) — فقط توسط Host قابل اعمال است.
- `ESC` یا بستن پنجره = خروج.

---

## قوانین بازی و امتیازدهی

- زمین بازی مربع 600×600 پیکسل است.
- هر بازیکن دو ضلع مجاور را در اختیار دارد:
  - A: بالا و راست
  - B: پایین و چپ
- توپ‌ها از مرکز با جهت تصادفی شروع می‌شوند. تعداد توپ‌ها ۱ یا ۲ (قابل انتخاب در تنظیمات).
- اگر توپ به **ضلع** متعلق به یک بازیکن برخورد کند و **پدل همان ضلع** آن نقطه را **نپوشانده باشد**:
  - برای صاحب آن ضلع **۱ امتیاز منفی** ثبت می‌شود.
  - برای حریف **۱ امتیاز مثبت** ثبت می‌شود.
  - توپ به مرکز ریست می‌شود (با جهت تصادفی جدید).
- پایان بازی: رسیدن یکی از بازیکنان به امتیاز هدف یا اتمام زمان (اگر زمان>۰ تعیین شده باشد).

---

## معماری شبکه و همگام‌سازی

- **سرور (Host)** مالک شبیه‌سازی است: فیزیک، برخورد، امتیاز، پایان بازی.
- کلاینت‌ها تنها **دستور ورودی** (حرکت پدل‌ها) را با نرخ بالا برای سرور می‌فرستند.
- سرور در هر تیک بازی، ورودی‌ها را اعمال کرده و **State** را برای هر دو طرف پخش می‌کند.
- قالب پیام‌ها **JSON** و فریمینگ به‌صورت **یک JSON در هر خط** است.

انواع پیام‌ها:
- `hello` (از کلاینت به سرور): شروع اتصال + معرفی.
- `settings` (از سرور به همه): ارسال تنظیمات بازی.
- `start` (از سرور به همه): ارسال وضعیت اولیه‌ی پدل‌ها/توپ‌ها/امتیاز.
- `input` (از بازیکنان به سرور): وضعیت ورودی لحظه‌ای پدل‌ها.
- `state` (از سرور به همه): اسنپ‌شات وضعیت فعلی (توپ‌ها، پدل‌ها، امتیاز، زمان، ...).
- `game_over` (از سرور به همه): پایان بازی + برنده.

> برای سادگی و اطمینان، از **TCP** استفاده شده است. در صورت نیاز می‌توانید یک شاخه جدید برای **UDP** بسازید و تنها لایه‌ی انتقال را تغییر دهید.

---

## ساختار پروژه

```
netpong/
├── run.py                 # نقطه ورود: فرم تنظیمات (Tkinter) + اجرای بازی
├── requirements.txt
├── README.md
└── game/
    ├── common.py          # ثابت‌ها، داده‌ها و ابزارهای کمکی (JSON line, فیزیک پایه)
    ├── server.py          # سرور بازی: شبیه‌سازی و پخش state
    ├── client.py          # کلاینت: اتصال، ارسال input، دریافت state
    └── game.py            # حلقه‌ی pygame (رندر، ورودی محلی، مصرف state شبکه)
```

---

## توضیح پیاده‌سازی — صفر تا صد (خلاصه‌ی خط‌به‌خط)

> کدها با کامنت‌های دقیق همراه شده‌اند. در این بخش مسیر اجرا و نقاط کلیدی را توصیف می‌کنیم:

### 1) `run.py`
- فرم Tkinter می‌سازد: نقش بازیکن (Host/Client)، IP/Port، تعداد توپ، امتیاز هدف، زمان بازی.  
- پس از فشردن Start، براساس نقش:
  - **Host**: نمونه‌ی Server راه‌اندازی می‌شود، سپس حلقه‌ی `pygame` با نقش A اجرا می‌شود.
  - **Client**: اتصال به Host و سپس حلقه‌ی `pygame` با نقش B اجرا می‌شود.

### 2) `game/common.py`
- ثابت‌ها (ابعاد، سرعت‌ها، طول پدل، ...)، کلاس داده‌ی ساده برای توپ و ابزارهای JSON line (`send_json_line`/`recv_json_lines`) و قفل هم‌زمانی.  
- توابع هندسه‌ی برخورد با دیواره/پدل و ریست توپ‌ها.

### 3) `game/server.py`
- یک نخ (Thread) برای **قبول اتصال** کلاینت و ساخت سوکت ایجاد می‌شود.
- نخ اصلی سرور: حلقه‌ی تیک بازی با نرخ 60 FPS (فیکس‌تایم‌استپ با `time.perf_counter`).  
- ورودی‌های بازیکن A (محلی) و بازیکن B (از شبکه) اعمال می‌شود، پدل‌ها Clamp می‌شوند، توپ‌ها حرکت و برخورد محاسبه می‌شود.  
- در هر تیک، یک `state` کامل برای Host و Client ارسال می‌شود.  
- در رخداد امتیاز، بررسی پایان بازی و ارسال `game_over`.

### 4) `game/client.py`
- اتصال به سرور و ارسال `hello`.  
- نخ دریافت پیام‌ها: `settings`, `start`, `state`, `game_over` را می‌خواند و **آخرین state** را در متغیر thread-safe نگه می‌دارد.  
- متدی برای ارسال `input` بر اساس کلیدهای فشرده‌شده‌ی کاربر.

### 5) `game/game.py`
- پنجره‌ی pygame را می‌سازد، فونت/ساعت بازی را تنظیم می‌کند.  
- نگاشت کلیدها به حرکات پدل‌ها (برای Player A و Player B) تعریف می‌شود.  
- در حلقه‌ی رندر: ورودی محلی خوانده می‌شود، برای سرور/کلاینت ارسال می‌گردد، state رسم می‌شود، متن Score/Time نمایش داده می‌شود.  
- اگر `game_over` بیاید، بنر برنده نمایان شده و با فشار ESC خارج می‌شود.

---

## ارزیابی و پوشش شاخص‌ها

- ساختار و نظم: پوشه‌بندی، نام‌گذاری معنادار، کامنت‌گذاری دقیق ✅
- معماری Client-Server: سرور مرجع، کلاینت سبک ✅
- مدیریت اتصال شبکه: TCP، JSON line، هندل خطا و قطع اتصال ✅
- کنترل پدل با کیبورد: نگاشت کلیدها برای هر دو بازیکن ✅
- رندر گرافیکی: pygame با زمین، پدل‌ها، توپ‌ها، امتیاز ✅
- حرکت و برخورد: فیزیک ساده، برخورد با پدل/دیواره، ریست توپ ✅
- سیستم امتیازدهی: لحظه‌ای، پایان بازی بر اساس امتیاز/زمان ✅
- همگام‌سازی داده: پخش state از سرور، ورودی از کلاینت ✅
- پردازش هم‌زمان: Thread جدا برای شبکه و شبیه‌سازی ✅
- ویژگی اضافه: فرم تنظیمات گرافیکی (Tkinter) + مستندسازی کامل ✅✅

---

## نکات توسعه‌ی بیشتر (Optional Ideas)

- مهاجرت state به **UDP** برای کاهش تاخیر (به‌همراه Ping/Pong یا Sequence Number).  
- فشرده‌سازی JSON با msgpack/CBOR یا کاهش فیلدها.  
- انیمیشن‌های زیباتر (trail توپ، افکت برخورد، صدا).  
- چند‌نفره‌ی بیش از دو بازیکن یا حالت تماشاچی.
